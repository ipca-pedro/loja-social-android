const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const pool = require('../db');
const authenticateToken = require('../middleware/authMiddleware'); // Importante!
const router = express.Router();

const JWT_SECRET = process.env.JWT_SECRET || 'a-minha-chave-secreta-para-a-loja-social-12345';

// POST /api/auth/login
router.post('/login', async (req, res) => {
  try {
    const { email, password, userType } = req.body;
    
    //console.log('üì± Login Request:', { email, userType }); 
    
    if (!email || !password) {
      return res.status(400).json({ success: false, message: 'Email e password s√£o obrigat√≥rios' });
    }

    let user, passwordMatch, role;

    // --- L√≥gica Benefici√°rio ---
    if (userType === 'beneficiario') {
      const result = await pool.query(
        'SELECT * FROM beneficiarios WHERE email = $1 AND estado = $2',
        [email, 'ativo']
      );

      if (result.rows.length === 0) {
        return res.status(401).json({ success: false, message: 'Benefici√°rio n√£o encontrado ou inativo' });
      }

      user = result.rows[0];
      role = 'beneficiario';

      // Valida√ß√£o: Password (Hash) OU NIF (Inicial)
      if (user.password_hash) {
          passwordMatch = await bcrypt.compare(password, user.password_hash);
      } else {
          passwordMatch = (password === user.nif);
      }
    
    // --- L√≥gica Colaborador ---
    } else {
      const result = await pool.query('SELECT * FROM colaboradores WHERE email = $1', [email]);

      if (result.rows.length === 0) {
        return res.status(401).json({ success: false, message: 'Colaborador n√£o encontrado' });
      }

      user = result.rows[0];
      role = 'admin'; // Android espera 'admin'

      if (user.password_hash && user.password_hash.startsWith('$2')) {
          passwordMatch = await bcrypt.compare(password, user.password_hash);
      } else {
          passwordMatch = (password === user.password_hash);
      }
    }
    
    if (!passwordMatch) {
      return res.status(401).json({ success: false, message: 'Credenciais inv√°lidas' });
    }

    // Gerar Token
    const payload = { 
      id: user.id, 
      email: user.email, 
      nome: user.nome_completo || user.nome, 
      role: role 
    };
    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '8h' });

    res.json({
      success: true,
      message: 'Login realizado com sucesso',
      token: token,
      role: role,
      nome: user.nome_completo || user.nome
    });

  } catch (error) {
    console.error('Erro no login:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// POST /api/auth/change-password
router.post('/change-password', authenticateToken, async (req, res) => {
  try {
    const { password_antiga, password_nova } = req.body;
    const userId = req.user.id;
    const userRole = req.user.role; 

    if (!password_antiga || !password_nova) {
      return res.status(400).json({ success: false, message: 'Preencha todos os campos' });
    }

    // Identificar tabela correta
    // Nota: O token pode trazer 'admin' ou 'beneficiario'
    const table = (userRole === 'beneficiario') ? 'beneficiarios' : 'colaboradores';

    // 1. Buscar utilizador atual
    const userResult = await pool.query(`SELECT * FROM ${table} WHERE id = $1`, [userId]);
    if (userResult.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Utilizador n√£o encontrado' });
    }
    const user = userResult.rows[0];

    // 2. Validar password antiga
    let validOld = false;
    // Se for benefici√°rio sem hash definida, a password antiga √© o NIF
    if (userRole === 'beneficiario' && !user.password_hash) {
         validOld = (password_antiga === user.nif);
    } else {
         // Valida√ß√£o normal (com hash ou plain text falllback)
         if (user.password_hash && user.password_hash.startsWith('$2')) {
            validOld = await bcrypt.compare(password_antiga, user.password_hash);
         } else {
            validOld = (password_antiga === user.password_hash);
         }
    }

    if (!validOld) {
         return res.status(401).json({ success: false, message: 'A palavra-passe antiga est√° incorreta' });
    }
    
    // 3. Gerar Hash da Nova Password
    const salt = await bcrypt.genSalt(10);
    const newHash = await bcrypt.hash(password_nova, salt);
    
    // 4. Atualizar na Base de Dados
    await pool.query(`UPDATE ${table} SET password_hash = $1 WHERE id = $2`, [newHash, userId]);

    res.json({ success: true, message: 'Palavra-passe alterada com sucesso' });

  } catch (error) {
    console.error('Erro ao alterar password:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

module.exports = router;