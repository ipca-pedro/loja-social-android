const express = require('express');
const pool = require('../db');
const authenticateToken = require('../middleware/authMiddleware');
const router = express.Router();

// Aplicar middleware de autenticação a TODAS as rotas deste ficheiro
router.use(authenticateToken);

// ===== GESTÃO DE BENEFICIÁRIOS (RF2) =====

// GET /api/beneficiarios - Listar todos os beneficiários
router.get('/beneficiarios', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT id, nome_completo, num_estudante, nif, ano_curricular, 
             curso, email, telefone, notas_adicionais, estado, data_registo
      FROM beneficiarios 
      ORDER BY nome_completo
    `);
    
    res.json({
      success: true,
      data: result.rows
    });
  } catch (error) {
    console.error('Erro ao listar beneficiários:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// POST /api/admin/beneficiarios
// Detectar violações de UNIQUE e retornar mensagens específicas

router.post('/beneficiarios', async (req, res) => {
  try {
    const { nome_completo, num_estudante, nif, ano_curricular, curso, email, telefone, notas_adicionais } = req.body;
    
    if (!nome_completo || !email) {
      return res.status(400).json({
        success: false,
        message: 'Nome e email são obrigatórios'
      });
    }

    // Validação de formato de email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({
        success: false,
        message: 'Formato de email inválido'
      });
    }

    // Validação de NIF (9 dígitos se fornecido)
    if (nif && (nif.length !== 9 || !/^\d+$/.test(nif))) {
      return res.status(400).json({
        success: false,
        message: 'NIF deve ter exatamente 9 dígitos'
      });
    }

    const result = await pool.query(`
      INSERT INTO beneficiarios (nome_completo, num_estudante, nif, ano_curricular, curso, email, telefone, notas_adicionais)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      RETURNING id, nome_completo, num_estudante, estado
    `, [nome_completo, num_estudante, nif, ano_curricular, curso, email, telefone, notas_adicionais]);

    res.status(201).json({
      success: true,
      message: 'Beneficiário criado com sucesso',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao criar beneficiário:', error);
    
    // Detectar violações de constraint UNIQUE
    if (error.code === '23505') { // PostgreSQL unique violation error code
      const constraint = error.constraint;
      let message = 'Erro ao criar beneficiário';
      
      if (constraint && constraint.includes('email')) {
        message = 'Este email já está registado. Use outro email.';
      } else if (constraint && constraint.includes('num_estudante')) {
        message = 'Este número de estudante já está registado.';
      } else if (constraint && constraint.includes('nif')) {
        message = 'Este NIF já está registado.';
      } else {
        message = 'Já existe um registo com estes dados (email, número de estudante ou NIF).';
      }
      
      return res.status(409).json({ // 409 Conflict é mais apropriado que 500
        success: false,
        message: message
      });
    }
    
    // Outros erros de base de dados
    if (error.code && error.code.startsWith('23')) {
      return res.status(400).json({
        success: false,
        message: 'Erro de validação: ' + (error.message || 'Dados inválidos')
      });
    }
    
    // Erro genérico
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

// PUT /api/beneficiarios/:id - Editar/Reativar beneficiário

router.put('/beneficiarios/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { nome_completo, num_estudante, nif, ano_curricular, curso, email, telefone, estado, notas_adicionais } = req.body;
    
    // Validações similares...
    
    const result = await pool.query(`
      UPDATE beneficiarios 
      SET nome_completo = $1, num_estudante = $2, nif = $3, ano_curricular = $4,
          curso = $5, email = $6, telefone = $7, estado = $8, notas_adicionais = $9
      WHERE id = $10
      RETURNING id, nome_completo, estado
    `, [nome_completo, num_estudante, nif, ano_curricular, curso, email, telefone, estado, notas_adicionais, id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Beneficiário não encontrado' });
    }

    res.json({
      success: true,
      message: 'Beneficiário atualizado com sucesso',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao atualizar beneficiário:', error);
    
    // Mesmo tratamento de erros UNIQUE
    if (error.code === '23505') {
      const constraint = error.constraint;
      let message = 'Erro ao atualizar beneficiário';
      
      if (constraint && constraint.includes('email')) {
        message = 'Este email já está registado noutro beneficiário.';
      } else if (constraint && constraint.includes('num_estudante')) {
        message = 'Este número de estudante já está registado noutro beneficiário.';
      } else if (constraint && constraint.includes('nif')) {
        message = 'Este NIF já está registado noutro beneficiário.';
      }
      
      return res.status(409).json({
        success: false,
        message: message
      });
    }
    
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});


// ===== GESTÃO DE INVENTÁRIO (RF3 & RF6) =====

// POST /api/stock - Adicionar novo lote de stock
router.post('/stock', async (req, res) => {
  try {
    const { produto_id, quantidade_inicial, data_validade, campanha_id } = req.body;
    const colaborador_id = req.user.id;
    
    if (!produto_id || !quantidade_inicial) {
      return res.status(400).json({ success: false, message: 'Produto e quantidade são obrigatórios' });
    }

    const result = await pool.query(`
      INSERT INTO stock_items (produto_id, quantidade_inicial, quantidade_atual, data_validade, campanha_id, colaborador_id)
      VALUES ($1, $2, $2, $3, $4, $5)
      RETURNING id, quantidade_inicial, data_validade
    `, [produto_id, quantidade_inicial, data_validade, campanha_id, colaborador_id]);

    res.status(201).json({
      success: true,
      message: 'Stock adicionado com sucesso',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao adicionar stock:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// POST /api/produtos - Criar um novo tipo de produto
router.post('/produtos', async (req, res) => {
  try {
    const { nome, descricao, categoria_id } = req.body;
    
    if (!nome || !categoria_id) {
      return res.status(400).json({ success: false, message: 'Nome e categoria são obrigatórios' });
    }

    const result = await pool.query(`
      INSERT INTO produtos (nome, descricao, categoria_id)
      VALUES ($1, $2, $3)
      RETURNING id, nome, descricao, categoria_id
    `, [nome, descricao, categoria_id]);

    res.status(201).json({
      success: true,
      message: 'Produto criado com sucesso',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao criar produto:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/produtos - Listar tipos de produto
router.get('/produtos', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT p.id, p.nome, p.descricao, c.nome as categoria
      FROM produtos p
      LEFT JOIN categorias c ON p.categoria_id = c.id
      ORDER BY c.nome, p.nome
    `);
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Erro ao listar produtos:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/categorias - Listar categorias de produtos
router.get('/categorias', async (req, res) => {
  try {
    const result = await pool.query('SELECT id, nome FROM categorias ORDER BY nome');
    
    res.json({
      success: true,
      data: result.rows
    });
  } catch (error) {
    console.error('Erro ao listar categorias:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/stock - Listar stock agrupado por produto para Android
router.get('/stock', async (req, res) => {
  try {
    const result = await pool.query('SELECT p.id as produto_id, p.nome as produto, c.nome as categoria, SUM(s.quantidade_atual) as quantidade_total, COUNT(s.id) as lotes, MIN(s.data_validade) as validade_proxima FROM stock_items s JOIN produtos p ON s.produto_id = p.id LEFT JOIN categorias c ON p.categoria_id = c.id WHERE s.quantidade_atual > 0 GROUP BY p.id, p.nome, c.nome HAVING SUM(s.quantidade_atual) > 0 ORDER BY p.nome ASC');
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Erro ao listar stock:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});


// GET /api/admin/stock/produto/:produto_id - Listar lotes individuais de um produto
router.get('/stock/produto/:produto_id', async (req, res) => {
  try {
    const { produto_id } = req.params;
    
    const result = await pool.query(`
      SELECT 
        si.id,
        si.quantidade_inicial,
        si.quantidade_atual,
        si.data_entrada,
        si.data_validade,
        p.nome as produto,
        c.nome as categoria
      FROM stock_items si
      JOIN produtos p ON si.produto_id = p.id
      LEFT JOIN categorias c ON p.categoria_id = c.id
      WHERE si.produto_id = $1 AND si.quantidade_atual > 0
      ORDER BY 
        CASE WHEN si.data_validade IS NULL THEN 1 ELSE 0 END,
        si.data_validade ASC
    `, [produto_id]);

    res.json({
      success: true,
      data: result.rows
    });
  } catch (error) {
    console.error('Erro ao listar lotes do produto:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// PUT /api/stock/:id - Editar lote de stock
router.put('/stock/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { quantidade_atual, data_validade } = req.body;
    
    const result = await pool.query('UPDATE stock_items SET quantidade_atual = $1, data_validade = $2 WHERE id = $3 RETURNING id, quantidade_atual, data_validade', [quantidade_atual, data_validade, id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Lote não encontrado' });
    }

    res.json({ success: true, message: 'Stock atualizado', data: result.rows[0] });
  } catch (error) {
    console.error('Erro ao atualizar stock:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// DELETE /api/stock/:id - Remover lote de stock
router.delete('/stock/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query('DELETE FROM stock_items WHERE id = $1 RETURNING id', [id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Lote não encontrado' });
    }

    res.json({ success: true, message: 'Lote removido com sucesso' });
  } catch (error) {
    console.error('Erro ao remover stock:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/alertas/validade - Produtos próximos do vencimento (RF6)
router.get('/alertas/validade', async (req, res) => {
  try {
    const result = await pool.query('SELECT s.id, p.nome as produto, s.quantidade_atual, s.data_validade, (s.data_validade - CURRENT_DATE) as dias_restantes FROM stock_items s JOIN produtos p ON s.produto_id = p.id WHERE s.data_validade IS NOT NULL AND s.data_validade <= CURRENT_DATE + INTERVAL \'30 days\' AND s.quantidade_atual > 0 ORDER BY s.data_validade ASC');
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Erro ao obter alertas de validade:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// ===== GESTÃO DE ENTREGAS (RF4) =====

// POST /api/entregas - Agendar nova entrega
router.post('/entregas', async (req, res) => {
  try {
    const { beneficiario_id, data_agendamento, itens } = req.body;
    const colaborador_id = req.user.id;
    
    if (!beneficiario_id || !data_agendamento || !itens || itens.length === 0) {
      return res.status(400).json({ success: false, message: 'Beneficiário, data e itens são obrigatórios' });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');
      
      const entregaResult = await client.query(`
        INSERT INTO entregas (beneficiario_id, colaborador_id, data_agendamento)
        VALUES ($1, $2, $3)
        RETURNING id
      `, [beneficiario_id, colaborador_id, data_agendamento]);
      
      const entrega_id = entregaResult.rows[0].id;
      
      for (const item of itens) {
        await client.query(`
          INSERT INTO detalhes_entrega (entrega_id, stock_item_id, quantidade_entregue) 
          VALUES ($1, $2, $3)
        `, [entrega_id, item.stock_item_id, item.quantidade_entregue]);
      }
      
      await client.query('COMMIT');
      
      res.status(201).json({
        success: true,
        message: 'Entrega agendada com sucesso',
        data: { id: entrega_id }
      });
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Erro ao agendar entrega:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/entregas - Listar entregas
router.get('/entregas', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT e.id, e.data_agendamento, e.estado, 
             COALESCE(b.nome_completo, 'Beneficiário Removido') as beneficiario, 
             b.num_estudante,
             COALESCE(c.nome, 'Colaborador Removido') as colaborador
      FROM entregas e
      LEFT JOIN beneficiarios b ON e.beneficiario_id = b.id
      LEFT JOIN colaboradores c ON e.colaborador_id = c.id
      ORDER BY e.data_agendamento DESC
    `);
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Erro ao listar entregas:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// PUT /api/entregas/:id/concluir - Concluir entrega
router.put('/entregas/:id/concluir', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      UPDATE entregas 
      SET estado = 'entregue'
      WHERE id = $1 AND estado = 'agendada'
      RETURNING id, estado
    `, [id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Entrega não encontrada ou já concluída' });
    }

    res.json({
      success: true,
      message: 'Entrega concluída com sucesso',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao concluir entrega:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// ===== GESTÃO DE CAMPANHAS =====

// POST /api/admin/campanhas - Criar nova campanha
router.post('/campanhas', async (req, res) => {
  try {
    const { nome, descricao, data_inicio, data_fim, ativo } = req.body;
    
    if (!nome || !data_inicio || !data_fim) {
      return res.status(400).json({ success: false, message: 'Nome e datas são obrigatórios' });
    }

    const result = await pool.query(`
      INSERT INTO campanhas (nome, descricao, data_inicio, data_fim, ativo)
      VALUES ($1, $2, $3, $4, $5)
      RETURNING *
    `, [nome, descricao, data_inicio, data_fim, ativo !== undefined ? ativo : true]);

    res.status(201).json({
      success: true,
      message: 'Campanha criada com sucesso',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao criar campanha:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// PUT /api/admin/campanhas/:id - Atualizar campanha
router.put('/campanhas/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { nome, descricao, data_inicio, data_fim, ativo } = req.body;
    
    const result = await pool.query(`
      UPDATE campanhas 
      SET nome = $1, descricao = $2, data_inicio = $3, data_fim = $4, ativo = $5
      WHERE id = $6
      RETURNING *
    `, [nome, descricao, data_inicio, data_fim, ativo, id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Campanha não encontrada' });
    }

    res.json({
      success: true,
      message: 'Campanha atualizada com sucesso',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao atualizar campanha:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// DELETE /api/admin/campanhas/:id - Remover campanha
router.delete('/campanhas/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Verificar se existem stocks associados a esta campanha
    const checkStock = await pool.query('SELECT id FROM stock_items WHERE campanha_id = $1 LIMIT 1', [id]);
    if (checkStock.rows.length > 0) {
      return res.status(400).json({ 
        success: false, 
        message: 'Não é possível remover esta campanha pois existem itens de stock associados. Tente inativá-la.' 
      });
    }

    const result = await pool.query('DELETE FROM campanhas WHERE id = $1 RETURNING id', [id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Campanha não encontrada' });
    }

    res.json({ success: true, message: 'Campanha removida com sucesso' });
  } catch (error) {
    console.error('Erro ao remover campanha:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

module.exports = router;