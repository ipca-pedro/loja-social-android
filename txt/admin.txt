const express = require('express');
const pool = require('../db');
const authenticateToken = require('../middleware/authMiddleware');
const router = express.Router();

// Aplicar middleware de autentica√ß√£o a TODAS as rotas deste ficheiro
router.use(authenticateToken);

// ===== GEST√ÉO DE BENEFICI√ÅRIOS (RF2) =====

// GET /api/beneficiarios - Listar todos os benefici√°rios
router.get('/beneficiarios', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT id, nome_completo, num_estudante, nif, ano_curricular, 
             curso, email, telefone, notas_adicionais, estado, data_registo
      FROM beneficiarios 
      ORDER BY nome_completo
    `);
    
    res.json({
      success: true,
      data: result.rows
    });
  } catch (error) {
    console.error('Erro ao listar benefici√°rios:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// POST /api/admin/beneficiarios
// Detectar viola√ß√µes de UNIQUE e retornar mensagens espec√≠ficas

router.post('/beneficiarios', async (req, res) => {
  try {
    const { nome_completo, num_estudante, nif, ano_curricular, curso, email, telefone, notas_adicionais } = req.body;
    
    if (!nome_completo || !email) {
      return res.status(400).json({
        success: false,
        message: 'Nome e email s√£o obrigat√≥rios'
      });
    }

    // Valida√ß√£o de formato de email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({
        success: false,
        message: 'Formato de email inv√°lido'
      });
    }

    // Valida√ß√£o de NIF (9 d√≠gitos se fornecido)
    if (nif && (nif.length !== 9 || !/^\d+$/.test(nif))) {
      return res.status(400).json({
        success: false,
        message: 'NIF deve ter exatamente 9 d√≠gitos'
      });
    }

    const result = await pool.query(`
      INSERT INTO beneficiarios (nome_completo, num_estudante, nif, ano_curricular, curso, email, telefone, notas_adicionais)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      RETURNING id, nome_completo, num_estudante, estado
    `, [nome_completo, num_estudante, nif, ano_curricular, curso, email, telefone, notas_adicionais]);

    res.status(201).json({
      success: true,
      message: 'Benefici√°rio criado com sucesso',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao criar benefici√°rio:', error);
    
    // Detectar viola√ß√µes de constraint UNIQUE
    if (error.code === '23505') { // PostgreSQL unique violation error code
      const constraint = error.constraint;
      let message = 'Erro ao criar benefici√°rio';
      
      if (constraint && constraint.includes('email')) {
        message = 'Este email j√° est√° registado. Use outro email.';
      } else if (constraint && constraint.includes('num_estudante')) {
        message = 'Este n√∫mero de estudante j√° est√° registado.';
      } else if (constraint && constraint.includes('nif')) {
        message = 'Este NIF j√° est√° registado.';
      } else {
        message = 'J√° existe um registo com estes dados (email, n√∫mero de estudante ou NIF).';
      }
      
      return res.status(409).json({ // 409 Conflict √© mais apropriado que 500
        success: false,
        message: message
      });
    }
    
    // Outros erros de base de dados
    if (error.code && error.code.startsWith('23')) {
      return res.status(400).json({
        success: false,
        message: 'Erro de valida√ß√£o: ' + (error.message || 'Dados inv√°lidos')
      });
    }
    
    // Erro gen√©rico
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

// PUT /api/beneficiarios/:id - Editar/Reativar benefici√°rio

router.put('/beneficiarios/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { nome_completo, num_estudante, nif, ano_curricular, curso, email, telefone, estado, notas_adicionais } = req.body;
    
    // Valida√ß√µes similares...
    
    const result = await pool.query(`
      UPDATE beneficiarios 
      SET nome_completo = $1, num_estudante = $2, nif = $3, ano_curricular = $4,
          curso = $5, email = $6, telefone = $7, estado = $8, notas_adicionais = $9
      WHERE id = $10
      RETURNING id, nome_completo, estado
    `, [nome_completo, num_estudante, nif, ano_curricular, curso, email, telefone, estado, notas_adicionais, id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Benefici√°rio n√£o encontrado' });
    }

    res.json({
      success: true,
      message: 'Benefici√°rio atualizado com sucesso',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao atualizar benefici√°rio:', error);
    
    // Mesmo tratamento de erros UNIQUE
    if (error.code === '23505') {
      const constraint = error.constraint;
      let message = 'Erro ao atualizar benefici√°rio';
      
      if (constraint && constraint.includes('email')) {
        message = 'Este email j√° est√° registado noutro benefici√°rio.';
      } else if (constraint && constraint.includes('num_estudante')) {
        message = 'Este n√∫mero de estudante j√° est√° registado noutro benefici√°rio.';
      } else if (constraint && constraint.includes('nif')) {
        message = 'Este NIF j√° est√° registado noutro benefici√°rio.';
      }
      
      return res.status(409).json({
        success: false,
        message: message
      });
    }
    
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});


// ===== GEST√ÉO DE INVENT√ÅRIO (RF3 & RF6) =====

// POST /api/stock - Adicionar novo lote de stock
router.post('/stock', async (req, res) => {
  try {
    const { produto_id, quantidade_inicial, data_validade, campanha_id } = req.body;
    const colaborador_id = req.user.id;
    
    if (!produto_id || !quantidade_inicial) {
      return res.status(400).json({ success: false, message: 'Produto e quantidade s√£o obrigat√≥rios' });
    }

    const result = await pool.query(`
      INSERT INTO stock_items (produto_id, quantidade_inicial, quantidade_atual, data_validade, campanha_id, colaborador_id)
      VALUES ($1, $2, $2, $3, $4, $5)
      RETURNING id, quantidade_inicial, data_validade
    `, [produto_id, quantidade_inicial, data_validade, campanha_id, colaborador_id]);

    res.status(201).json({
      success: true,
      message: 'Stock adicionado com sucesso',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao adicionar stock:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/produtos - Listar tipos de produto
router.get('/produtos', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT p.id, p.nome, p.descricao, c.nome as categoria
      FROM produtos p
      LEFT JOIN categorias c ON p.categoria_id = c.id
      ORDER BY c.nome, p.nome
    `);
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Erro ao listar produtos:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/categorias - Listar categorias de produtos
router.get('/categorias', async (req, res) => {
  try {
    const result = await pool.query('SELECT id, nome FROM categorias ORDER BY nome');
    
    res.json({
      success: true,
      data: result.rows
    });
  } catch (error) {
    console.error('Erro ao listar categorias:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/stock - Listar stock agrupado por produto para Android
// [CORRIGIDO] Soma a quantidade_atual (F√≠sica) em vez do dispon√≠vel
router.get('/stock', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT 
        p.id as produto_id, 
        p.nome as produto, 
        c.nome as categoria, 
        SUM(s.quantidade_atual) as quantidade_total, 
        COUNT(s.id) as lotes, 
        MIN(s.data_validade) as validade_proxima 
      FROM stock_items s 
      JOIN produtos p ON s.produto_id = p.id 
      LEFT JOIN categorias c ON p.categoria_id = c.id 
      WHERE s.quantidade_atual > 0 
      GROUP BY p.id, p.nome, c.nome 
      HAVING SUM(s.quantidade_atual) >= 0 
      ORDER BY p.nome ASC
    `);
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Erro ao listar stock:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});


// GET /api/admin/stock/lotes - Listar TODOS os lotes individuais dispon√≠veis
router.get('/stock/lotes', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT 
        si.id,
        si.quantidade_inicial,
        si.quantidade_atual,
        si.quantidade_reservada,
        si.quantidade_danificada,
        si.data_entrada,
        si.data_validade,
        p.nome as produto,
        c.nome as categoria
      FROM stock_items si
      JOIN produtos p ON si.produto_id = p.id
      LEFT JOIN categorias c ON p.categoria_id = c.id
      WHERE si.quantidade_atual > 0
      ORDER BY 
        p.nome ASC,
        CASE WHEN si.data_validade IS NULL THEN 1 ELSE 0 END,
        si.data_validade ASC
    `);

    res.json({
      success: true,
      data: result.rows
    });
  } catch (error) {
    console.error('Erro ao listar todos os lotes:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/admin/stock/produto/:produto_id - Listar lotes individuais de um produto
router.get('/stock/produto/:produto_id', async (req, res) => {
  try {
    const { produto_id } = req.params;
    
    const result = await pool.query(`
      SELECT 
        si.id,
        si.quantidade_inicial,
        si.quantidade_atual,
        si.quantidade_reservada,
        si.quantidade_danificada,
        (si.quantidade_atual - si.quantidade_reservada) as quantidade_disponivel,
        si.data_entrada,
        si.data_validade,
        p.nome as produto,
        c.nome as categoria
      FROM stock_items si
      JOIN produtos p ON si.produto_id = p.id
      LEFT JOIN categorias c ON p.categoria_id = c.id
      WHERE si.produto_id = $1 AND si.quantidade_atual > 0
      ORDER BY 
        CASE WHEN si.data_validade IS NULL THEN 1 ELSE 0 END,
        si.data_validade ASC
    `, [produto_id]);

    res.json({
      success: true,
      data: result.rows
    });
  } catch (error) {
    console.error('Erro ao listar lotes do produto:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// PUT /api/stock/:id - Editar lote de stock (incluindo danos)
router.put('/stock/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { quantidade_atual, data_validade, quantidade_danificada } = req.body;
    
    // Constr√≥i a query dinamicamente ou mantem simples se sempre enviarmos tudo
    // Aqui assumimos que o Android envia o objeto atualizado
    
    const result = await pool.query(
        `UPDATE stock_items 
         SET quantidade_atual = $1, 
             data_validade = $2, 
             quantidade_danificada = COALESCE($3, quantidade_danificada) 
         WHERE id = $4 
         RETURNING id, quantidade_atual, data_validade, quantidade_danificada`, 
        [quantidade_atual, data_validade, quantidade_danificada, id]
    );
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Lote n√£o encontrado' });
    }
    res.json({ success: true, message: 'Stock atualizado', data: result.rows[0] });
  } catch (error) {
    console.error('Erro ao atualizar stock:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// POST /api/stock/:id/danificar - Reportar unidade danificada (Atomic Increment)
router.post('/stock/:id/danificar', async (req, res) => {
  try {
    const { id } = req.params;
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        
        // 1. Verificar disponibilidade
        const check = await client.query('SELECT quantidade_atual FROM stock_items WHERE id = $1 FOR UPDATE', [id]);
        if (check.rows.length === 0) throw new Error('Lote n√£o encontrado');
        if (check.rows[0].quantidade_atual <= 0) throw new Error('N√£o existe stock dispon√≠vel para reportar danos');
        // 2. Atualizar atomicamente
        const result = await client.query(`
            UPDATE stock_items 
            SET quantidade_atual = quantidade_atual - 1,
                quantidade_danificada = COALESCE(quantidade_danificada, 0) + 1
            WHERE id = $1
            RETURNING id, quantidade_atual, quantidade_danificada, data_validade
        `, [id]);
        await client.query('COMMIT');
        
        res.json({ success: true, message: 'Unidade danificada reportada', data: result.rows[0] });
    } catch (e) {
        await client.query('ROLLBACK');
        if (e.message === 'Lote n√£o encontrado') return res.status(404).json({ success: false, message: e.message });
        if (e.message.startsWith('N√£o existe stock')) return res.status(400).json({ success: false, message: e.message });
        throw e;
    } finally {
        client.release();
    }
  } catch (error) {
    console.error('Erro ao reportar dano:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// DELETE /api/stock/:id - Remover lote de stock
router.delete('/stock/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query('DELETE FROM stock_items WHERE id = $1 RETURNING id', [id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Lote n√£o encontrado' });
    }

    res.json({ success: true, message: 'Lote removido com sucesso' });
  } catch (error) {
    console.error('Erro ao remover stock:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// POST /api/produtos - Criar um novo tipo de produto
router.post('/produtos', async (req, res) => {
  try {
    const { nome, descricao, categoria_id } = req.body;
    
    if (!nome || !categoria_id) {
      return res.status(400).json({ success: false, message: 'Nome e categoria s√£o obrigat√≥rios' });
    }

    const result = await pool.query(`
      INSERT INTO produtos (nome, descricao, categoria_id)
      VALUES ($1, $2, $3)
      RETURNING id, nome, descricao, categoria_id
    `, [nome, descricao, categoria_id]);

    res.status(201).json({
      success: true,
      message: 'Produto criado com sucesso',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao criar produto:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/alertas/validade - Produtos pr√≥ximos do vencimento (RF6)
router.get('/alertas/validade', async (req, res) => {
  try {
    const result = await pool.query('SELECT s.id, p.nome as produto, s.quantidade_atual, s.data_validade, (s.data_validade - CURRENT_DATE) as dias_restantes FROM stock_items s JOIN produtos p ON s.produto_id = p.id WHERE s.data_validade IS NOT NULL AND s.data_validade <= CURRENT_DATE + INTERVAL \'30 days\' AND s.quantidade_atual > 0 ORDER BY s.data_validade ASC');
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Erro ao obter alertas de validade:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// ===== GEST√ÉO DE ENTREGAS (RF4) =====

// POST /api/entregas - Agendar nova entrega com valida√ß√£o de stock e reserva
router.post('/entregas', async (req, res) => {
  try {
    const { beneficiario_id, data_agendamento, itens } = req.body;
    const colaborador_id = req.user.id;
    
    if (!beneficiario_id || !data_agendamento || !itens || itens.length === 0) {
      return res.status(400).json({ success: false, message: 'Benefici√°rio, data e itens s√£o obrigat√≥rios' });
    }
    const client = await pool.connect();
    try {
      await client.query('BEGIN');
      
      // 1. Validar Stock e Criar Reservas
      for (const item of itens) {
         // Verificar stock dispon√≠vel (Total - Reservado)
         const stockCheck = await client.query(
             'SELECT quantidade_atual, quantidade_reservada, quantidade_danificada FROM stock_items WHERE id = $1 FOR UPDATE', 
             [item.stock_item_id]
         );
         
         if (stockCheck.rows.length === 0) {
             throw new Error(`Item de stock ${item.stock_item_id} n√£o encontrado`);
         }
         
         const currentStock = stockCheck.rows[0];
         // A quantidade_atual j√° exclui os danificados (que foram abatidos ao reportar dano)
         const disponivel = currentStock.quantidade_atual - currentStock.quantidade_reservada;
         
         if (disponivel < item.quantidade_entregue) {
             throw new Error(`N√£o √© poss√≠vel agendar esta quantidade. Atualmente, apenas tem ${disponivel} unidades dispon√≠veis para novos agendamentos (Stock F√≠sico Dispon√≠vel: ${currentStock.quantidade_atual} | Reservado: ${currentStock.quantidade_reservada}).`);
         }
         
         // Atualizar reserva
         await client.query(
             'UPDATE stock_items SET quantidade_reservada = quantidade_reservada + $1 WHERE id = $2',
             [item.quantidade_entregue, item.stock_item_id]
         );
      }
      
      // 2. Criar a Entrega
      const entregaResult = await client.query(`
        INSERT INTO entregas (beneficiario_id, colaborador_id, data_agendamento)
        VALUES ($1, $2, $3)
        RETURNING id
      `, [beneficiario_id, colaborador_id, data_agendamento]);
      
      const entrega_id = entregaResult.rows[0].id;
      
      // 3. Criar Detalhes
      for (const item of itens) {
        await client.query(`
          INSERT INTO detalhes_entrega (entrega_id, stock_item_id, quantidade_entregue) 
          VALUES ($1, $2, $3)
        `, [entrega_id, item.stock_item_id, item.quantidade_entregue]);
      }
      
      
      // 4. Criar Notifica√ß√£o
      await client.query(`
        INSERT INTO notificacoes (beneficiario_id, entrega_id, titulo, mensagem)
        VALUES ($1, $2, $3, $4)
      `, [beneficiario_id, entrega_id, 'Nova Entrega Agendada', `Tens uma entrega agendada para ${data_agendamento}.`]);
      
      await client.query('COMMIT');
      
      res.status(201).json({
        success: true,
        message: 'Entrega agendada com sucesso (Stock reservado)',
        data: { id: entrega_id }
      });
    } catch (error) {
      await client.query('ROLLBACK');
      if (error.message.startsWith('Stock insuficiente') || error.message.startsWith('Item de stock') || error.message.startsWith('N√£o √© poss√≠vel agendar')) {
          return res.status(400).json({ success: false, message: error.message });
      }
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Erro ao agendar entrega:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/entregas - Listar entregas (filtrado por role)
router.get('/entregas', async (req, res) => {
  try {
    console.log('üì¶ REQUEST ENTREGAS - User:', req.user.nome, 'Role:', req.user.role);
    
    let query, params;
    
    if (req.user.role === 'beneficiario') {
      // Benefici√°rio v√™ apenas as suas entregas
      console.log('üéì Filtrando entregas para benefici√°rio:', req.user.id);
      query = `
        SELECT e.id, e.data_agendamento, e.estado,
               COALESCE(c.nome, 'Colaborador Removido') as colaborador,
               COUNT(de.id) as total_itens
        FROM entregas e
        LEFT JOIN colaboradores c ON e.colaborador_id = c.id
        LEFT JOIN detalhes_entrega de ON e.id = de.entrega_id
        WHERE e.beneficiario_id = $1
        GROUP BY e.id, e.data_agendamento, e.estado, c.nome
        ORDER BY e.data_agendamento DESC
      `;
      params = [req.user.id];
    } else {
      // Admin v√™ todas as entregas
      console.log('üë®üíº Listando todas as entregas para admin');
      query = `
        SELECT e.id, e.data_agendamento, e.estado, 
               COALESCE(b.nome_completo, 'Benefici√°rio Removido') as beneficiario, 
               b.num_estudante,
               COALESCE(c.nome, 'Colaborador Removido') as colaborador
        FROM entregas e
        LEFT JOIN beneficiarios b ON e.beneficiario_id = b.id
        LEFT JOIN colaboradores c ON e.colaborador_id = c.id
        ORDER BY e.data_agendamento DESC
      `;
      params = [];
    }
    
    const result = await pool.query(query, params);
    console.log('‚úÖ Entregas encontradas:', result.rows.length);
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Erro ao listar entregas:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/entregas/:id/detalhes - Ver itens de uma entrega espec√≠fica
router.get('/entregas/:id/detalhes', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      SELECT 
        de.stock_item_id as id,
        de.quantidade_entregue,
        si.quantidade_inicial,
        si.quantidade_atual,
        si.quantidade_reservada,
        si.quantidade_danificada,
        si.data_entrada,
        si.data_validade,
        p.nome as produto,
        c.nome as categoria
      FROM detalhes_entrega de
      JOIN stock_items si ON de.stock_item_id = si.id
      JOIN produtos p ON si.produto_id = p.id
      LEFT JOIN categorias c ON p.categoria_id = c.id
      WHERE de.entrega_id = $1
      ORDER BY p.nome
    `, [id]);
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Erro ao listar detalhes da entrega:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/entregas/:id - Obter cabe√ßalho da entrega
router.get('/entregas/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query(`
      SELECT e.id, e.beneficiario_id, e.colaborador_id, e.data_agendamento, e.estado
      FROM entregas e
      WHERE e.id = $1
    `, [id]);
    
    if (result.rows.length === 0) return res.status(404).json({ success: false, message: 'Entrega n√£o encontrada' });
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('Erro ao obter entrega:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// PUT /api/entregas/:id/concluir - Concluir entrega
router.put('/entregas/:id/concluir', async (req, res) => {
  try {
    const { id } = req.params;
    
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        // 1. Obter itens para limpar a reserva
        const itensResult = await client.query('SELECT stock_item_id, quantidade_entregue FROM detalhes_entrega WHERE entrega_id = $1', [id]);
        
        // 2. Marcar como entregue
        const updateResult = await client.query(`
          UPDATE entregas 
          SET estado = 'entregue'
          WHERE id = $1 AND estado = 'agendada'
          RETURNING id, estado
        `, [id]);
        if (updateResult.rows.length === 0) {
          throw new Error('Entrega n√£o encontrada ou j√° conclu√≠da');
        }
        // 3. Abater na reserva (O Trigger da BD trata da quantidade_atual)
        for (const item of itensResult.rows) {
            await client.query(
                'UPDATE stock_items SET quantidade_reservada = quantidade_reservada - $1 WHERE id = $2',
                [item.quantidade_entregue, item.stock_item_id]
            );
        }
        await client.query('COMMIT');
        res.json({
          success: true,
          message: 'Entrega conclu√≠da com sucesso',
          data: updateResult.rows[0]
        });
    } catch (error) {
        await client.query('ROLLBACK');
        if (error.message === 'Entrega n√£o encontrada ou j√° conclu√≠da') {
            return res.status(404).json({ success: false, message: error.message });
        }
        throw error;
    } finally {
        client.release();
    }
  } catch (error) {
    console.error('Erro ao concluir entrega:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// PUT /api/entregas/:id - Editar Agendamento
router.put('/entregas/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { beneficiario_id, data_agendamento, itens } = req.body;
    
    if (!beneficiario_id || !data_agendamento || !itens || itens.length === 0) {
      return res.status(400).json({ success: false, message: 'Benefici√°rio, data e itens s√£o obrigat√≥rios' });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      // 1. Validar estado da entrega
      const check = await client.query('SELECT estado FROM entregas WHERE id = $1', [id]);
      if (check.rows.length === 0) throw new Error('Entrega n√£o encontrada');
      if (check.rows[0].estado !== 'agendada') throw new Error('Apenas entregas agendadas podem ser editadas');

      // 2. Reverter reservas antigas
      const oldItems = await client.query('SELECT stock_item_id, quantidade_entregue FROM detalhes_entrega WHERE entrega_id = $1 FOR UPDATE', [id]);
      for (const item of oldItems.rows) {
          await client.query(
              'UPDATE stock_items SET quantidade_reservada = quantidade_reservada - $1 WHERE id = $2',
              [item.quantidade_entregue, item.stock_item_id]
          );
      }

      // 3. Validar e Aplicar Novas Reservas
      for (const item of itens) {
         const stockCheck = await client.query(
             'SELECT quantidade_atual, quantidade_reservada FROM stock_items WHERE id = $1 FOR UPDATE', 
             [item.stock_item_id]
         );
         
         if (stockCheck.rows.length === 0) throw new Error(`Item de stock ${item.stock_item_id} n√£o encontrado`);
         
         const currentStock = stockCheck.rows[0];
         // Dispon√≠vel agora considera que j√° reverteu o antigo, ent√£o √© o estado "real" sem esta entrega
         const disponivel = currentStock.quantidade_atual - currentStock.quantidade_reservada;
         
         if (disponivel < item.quantidade_entregue) {
             throw new Error(`N√£o √© poss√≠vel guardar altera√ß√µes. Stock insuficiente para o item ${item.stock_item_id}. Dispon√≠vel: ${disponivel} (F√≠sico: ${currentStock.quantidade_atual} | Reservado Outros: ${currentStock.quantidade_reservada})`);
         }
         
         await client.query(
             'UPDATE stock_items SET quantidade_reservada = quantidade_reservada + $1 WHERE id = $2',
             [item.quantidade_entregue, item.stock_item_id]
         );
      }

      // 4. Atualizar Cabe√ßalho
      await client.query(
          'UPDATE entregas SET beneficiario_id = $1, data_agendamento = $2 WHERE id = $3',
          [beneficiario_id, data_agendamento, id]
      );

      // 5. Atualizar Detalhes (Apagar e Recriar)
      await client.query('DELETE FROM detalhes_entrega WHERE entrega_id = $1', [id]);
      for (const item of itens) {
          await client.query(
              'INSERT INTO detalhes_entrega (entrega_id, stock_item_id, quantidade_entregue) VALUES ($1, $2, $3)',
              [id, item.stock_item_id, item.quantidade_entregue]
          );
      }

      // 6. Criar Notifica√ß√£o de Atualiza√ß√£o
      await client.query(`
        INSERT INTO notificacoes (beneficiario_id, entrega_id, titulo, mensagem)
        VALUES ($1, $2, $3, $4)
      `, [beneficiario_id, id, 'Entrega Atualizada', `O teu agendamento para ${data_agendamento} foi atualizado.`]);

      await client.query('COMMIT');
      res.json({ success: true, message: 'Entrega atualizada com sucesso' });

    } catch (error) {
      await client.query('ROLLBACK');
      if (error.message.startsWith('Entrega') || error.message.startsWith('Apenas') || error.message.startsWith('N√£o √© poss√≠vel') || error.message.startsWith('Item')) {
          return res.status(400).json({ success: false, message: error.message });
      }
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Erro ao editar entrega:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// DELETE /api/entregas/:id - Cancelar Entrega (Remove reserva)
router.delete('/entregas/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        
        // 1. Verificar se entrega pode ser cancelada
        const check = await client.query('SELECT estado FROM entregas WHERE id = $1', [id]);
        if (check.rows.length === 0) throw new Error('Entrega n√£o encontrada');
        if (check.rows[0].estado !== 'agendada') throw new Error('Apenas entregas agendadas podem ser canceladas');
        // 2. Obter itens para devolver a reserva
        const itensResult = await client.query('SELECT stock_item_id, quantidade_entregue FROM detalhes_entrega WHERE entrega_id = $1', [id]);
        
        // 3. Devolver reserva
        for (const item of itensResult.rows) {
            await client.query(
                'UPDATE stock_items SET quantidade_reservada = quantidade_reservada - $1 WHERE id = $2',
                [item.quantidade_entregue, item.stock_item_id]
            );
        }
        
        // 4. Apagar entrega
        await client.query('DELETE FROM entregas WHERE id = $1', [id]);
        await client.query('COMMIT');
        res.json({ success: true, message: 'Entrega cancelada e reservas revertidas' });
    } catch (e) {
        await client.query('ROLLBACK');
        if (e.message.startsWith('Entrega') || e.message.startsWith('Apenas')) {
             return res.status(400).json({success: false, message: e.message});
        }
        throw e;
    } finally {
        client.release();
    }
  } catch (error) {
     console.error('Erro ao cancelar entrega:', error);
     res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// ===== GEST√ÉO DE CAMPANHAS =====

// POST /api/admin/campanhas - Criar nova campanha
router.post('/campanhas', async (req, res) => {
  try {
    const { nome, descricao, data_inicio, data_fim, ativo } = req.body;
    
    if (!nome || !data_inicio || !data_fim) {
      return res.status(400).json({ success: false, message: 'Nome e datas s√£o obrigat√≥rios' });
    }

    const result = await pool.query(`
      INSERT INTO campanhas (nome, descricao, data_inicio, data_fim, ativo)
      VALUES ($1, $2, $3, $4, $5)
      RETURNING *
    `, [nome, descricao, data_inicio, data_fim, ativo !== undefined ? ativo : true]);

    res.status(201).json({
      success: true,
      message: 'Campanha criada com sucesso',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao criar campanha:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// PUT /api/admin/campanhas/:id - Atualizar campanha
router.put('/campanhas/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { nome, descricao, data_inicio, data_fim, ativo } = req.body;
    
    const result = await pool.query(`
      UPDATE campanhas 
      SET nome = $1, descricao = $2, data_inicio = $3, data_fim = $4, ativo = $5
      WHERE id = $6
      RETURNING *
    `, [nome, descricao, data_inicio, data_fim, ativo, id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Campanha n√£o encontrada' });
    }

    res.json({
      success: true,
      message: 'Campanha atualizada com sucesso',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Erro ao atualizar campanha:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// DELETE /api/admin/campanhas/:id - Remover campanha
router.delete('/campanhas/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Verificar se existem stocks associados a esta campanha
    const checkStock = await pool.query('SELECT id FROM stock_items WHERE campanha_id = $1 LIMIT 1', [id]);
    if (checkStock.rows.length > 0) {
      return res.status(400).json({ 
        success: false, 
        message: 'N√£o √© poss√≠vel remover esta campanha pois existem itens de stock associados. Tente inativ√°-la.' 
      });
    }

    const result = await pool.query('DELETE FROM campanhas WHERE id = $1 RETURNING id', [id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Campanha n√£o encontrada' });
    }

    res.json({ success: true, message: 'Campanha removida com sucesso' });
  } catch (error) {
    console.error('Erro ao remover campanha:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// ===== RELAT√ìRIOS (RF5 & GAPS) =====

// GET /api/admin/relatorios/entregas - Relat√≥rio de Entregas por Per√≠odo
router.get('/relatorios/entregas', async (req, res) => {
  try {
    const { inicio, fim } = req.query;
    
    let query = `
      SELECT e.id, e.data_agendamento, e.estado, 
             b.nome_completo as beneficiario, b.num_estudante,
             c.nome as colaborador
      FROM entregas e
      LEFT JOIN beneficiarios b ON e.beneficiario_id = b.id
      LEFT JOIN colaboradores c ON e.colaborador_id = c.id
    `;
    
    const params = [];
    if (inicio && fim) {
      query += ` WHERE e.data_agendamento BETWEEN $1 AND $2`;
      params.push(inicio, fim);
    }
    
    query += ` ORDER BY e.data_agendamento DESC`;
    
    const result = await pool.query(query, params);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Erro no relat√≥rio de entregas:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/admin/relatorios/stock - Relat√≥rio de Stock vs Campanhas
router.get('/relatorios/stock', async (req, res) => {
  try {
    // Agrupar stock por campanha e produto
    const query = `
      SELECT 
        COALESCE(camp.nome, 'Sem Campanha (Stock Regular)') as campanha_nome,
        p.nome as produto_nome,
        cat.nome as categoria_nome,
        SUM(si.quantidade_atual) as quantidade_total,
        SUM(si.quantidade_inicial) as quantidade_recolhida
      FROM stock_items si
      JOIN produtos p ON si.produto_id = p.id
      LEFT JOIN categorias cat ON p.categoria_id = cat.id
      LEFT JOIN campanhas camp ON si.campanha_id = camp.id
      GROUP BY camp.nome, p.nome, cat.nome
      ORDER BY camp.nome, cat.nome, p.nome
    `;
    
    const result = await pool.query(query);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Erro no relat√≥rio de stock:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// GET /api/admin/relatorios/validade - Relat√≥rio de Produtos Expirados/Danificados
router.get('/relatorios/validade', async (req, res) => {
  try {
    const query = `
      SELECT 
        si.id,
        p.nome as produto_nome,
        cat.nome as categoria_nome,
        si.quantidade_atual,
        si.quantidade_danificada,
        si.data_validade,
        CASE 
          WHEN si.quantidade_danificada > 0 THEN 'Danificado'
          WHEN si.data_validade < CURRENT_DATE THEN 'Expirado'
          WHEN si.data_validade <= CURRENT_DATE + INTERVAL '7 days' THEN 'Cr√≠tico'
          WHEN si.data_validade <= CURRENT_DATE + INTERVAL '15 days' THEN 'Aten√ß√£o'
          WHEN si.data_validade <= CURRENT_DATE + INTERVAL '30 days' THEN 'Brevemente'
          ELSE 'OK'
        END as estado_item
      FROM stock_items si
      JOIN produtos p ON si.produto_id = p.id
      LEFT JOIN categorias cat ON p.categoria_id = cat.id
      WHERE (si.data_validade <= CURRENT_DATE + INTERVAL '30 days' AND si.quantidade_atual > 0)
         OR (si.quantidade_danificada > 0)
      ORDER BY 
        CASE 
            WHEN si.data_validade < CURRENT_DATE THEN 1
            WHEN si.quantidade_danificada > 0 THEN 2
            ELSE 3
        END,
        si.data_validade ASC
    `;
    
    const result = await pool.query(query);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Erro no relat√≥rio de validade:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});


// ===== NOTIFICA√á√ïES (RF7 - Extra) =====

// GET /api/notificacoes - Listar notifica√ß√µes do utilizador
router.get('/notificacoes', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT id, titulo, mensagem, lida, data_criacao, entrega_id
      FROM notificacoes
      WHERE beneficiario_id = $1 OR colaborador_id = $1
      ORDER BY data_criacao DESC
    `, [req.user.id]);
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Erro ao listar notifica√ß√µes:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

// PUT /api/notificacoes/:id/lida - Marcar como lida
router.put('/notificacoes/:id/lida', async (req, res) => {
  try {
    const { id } = req.params;
    // Garante que a notifica√ß√£o pertence ao user antes de marcar
    const result = await pool.query(`
      UPDATE notificacoes 
      SET lida = true 
      WHERE id = $1 AND (beneficiario_id = $2 OR colaborador_id = $2)
      RETURNING id, lida
    `, [id, req.user.id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Notifica√ß√£o n√£o encontrada' });
    }

    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('Erro ao marcar notifica√ß√£o:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

module.exports = router;